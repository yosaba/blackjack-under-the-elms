module Update exposing (newGame, playerDraw, update)

import Cards exposing (initialDeck)
import Debug
import Models exposing (..)
import Msgs exposing (..)

-- package: elm-community/random-extra
import Random exposing (Seed, generate)
import Random.List exposing (shuffle)
import Delay exposing (..)

update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NewGame ->
            ( newGame model ) |> assessState

        ResetGame ->
            ( Models.initialModel, Cmd.none )

        PlayerDraw ->
            ( playerDraw model ) |> assessState

        DealerDraw ->
            ( dealerDraw model ) |> assessState

        Stay ->
            ( { model | gameState = EndGame } ) |> assessState

        Shuffle ->
          ( model, generate ShuffleDeck (shuffle model.deck) )
              
        ShuffleDeck shuffledList ->
          ( { model | deck = shuffledList }, Cmd.none )

        AssessState ->
             assessState model
                  
        UpdateHistory ->
            updateHistory model

updateModelForNewGame : Model -> Model
updateModelForNewGame model =
     { model |
       gameState = DealerTurn
--       gameState = PlayerTurn
       , dealerCards = []
       , playerCards = []
     }

newGame : Model -> Model
newGame model =
    playerDraw ( updateModelForNewGame model )
    |> dealerDraw
    |> playerDraw
    |> dealerDraw


drawCard : Model -> ( Cards.Card, List Cards.Card )
drawCard model =
    case model.deck of
        x :: xs ->
            ( x, xs )

        [] ->
            -- reset the deck
            let
                newCard =
                    case List.head initialDeck of
                        Just card ->
                            card

                        Nothing ->
                            Cards.cardBack

                newDeck =
                    case List.tail initialDeck of
                        Just cards ->
                            cards

                        Nothing ->
                            initialDeck
            in
            ( newCard, newDeck )

mustDealerDraw : Model -> Bool
mustDealerDraw model =
    Cards.getHandValue model.dealerCards < 17

dealerDraw : Model -> Model
dealerDraw model =
    if mustDealerDraw model then
        let
            ( newCard, newDeck ) =
                drawCard model
        in
        { model
            | dealerCards = newCard :: model.dealerCards
            , deck = newDeck
--            , gameState = DealerTurn
        }
    else
        model


playerDraw : Model -> Model
playerDraw model =
    let
        ( newCard, newDeck ) =
            drawCard model
    in
    { model
        | playerCards = newCard :: model.playerCards
        , deck = newDeck
--        , gameState = PlayerTurn
    }



assessGame : Model -> GameState
assessGame model =
    let
        playerHandValue =
            Cards.getHandValue model.playerCards
        dealerHandValue =
            Cards.getHandValue model.dealerCards
    in
    if model.gameState == PlayerTurn then
        -- Player just had a turn
        if playerHandValue > maxHandValue then
            Lose

        else if dealerHandValue >= minDealerValue &&
            playerHandValue > dealerHandValue then
                 Win
        else
            DealerTurn

    -- We are in an End Game or Dealer just had a turn 
    -- Either way:
    else if dealerHandValue > maxHandValue then
            Win

    else if model.gameState == EndGame then
        if dealerHandValue < minDealerValue then
            EndGame
        else if dealerHandValue > maxHandValue then
            Win
        else if dealerHandValue > playerHandValue then
            Lose
        else if dealerHandValue == playerHandValue then
            Tie
        else
            Win

    else if dealerHandValue >= minDealerValue then
        if dealerHandValue < playerHandValue then
            Win
        else if playerHandValue == 21 then
             if dealerHandValue == 21 then
                 Tie
             else
                 -- Dealer can't draw
                 Win
         else
             -- Let the player decide
             PlayerTurn
    else
        PlayerTurn

     
assessState : Model -> ( Model, Cmd Msg )
assessState model =
    case assessGame model of
        Win ->
            ( { model | gameState = Win } ) |> updateHistory
--            ( { model | gameState = Win }, Cmd.none )

        Lose ->
            ( { model | gameState = Lose } ) |> updateHistory
--            ( { model | gameState = Lose }, Cmd.none )

        Tie ->
            ( { model | gameState = Tie } ) |> updateHistory
--            ( { model | gameState = Tie }, Cmd.none )

        PlayerTurn ->
            ( { model | gameState = PlayerTurn }, Cmd.none )
--            update PlayerDraw { model | gameState = PlayerTurn }

        DealerTurn ->
            ( { model | gameState = DealerTurn },  Delay.after 2000 Millisecond DealerDraw  )
--            update ( delay 2 DealerDraw ) { model | gameState = DealerTurn }
--            update DealerDraw { model | gameState = DealerTurn }

        EndGame ->
            ( { model | gameState = EndGame },  Delay.after 2000 Millisecond DealerDraw  )
--            update DealerDraw { model | gameState = EndGame }
--            ( { model | gameState = EndGame }, Cmd.none )
    
        Inactive ->
            ( { model | gameState = Inactive }, Cmd.none )



updateHistory : Model -> ( Model, Cmd Msg )
updateHistory model =
    let
        newHistoryRecord =
            {
            dealerCount = Cards.getHandValue model.dealerCards
            , numDealerCards = List.length model.dealerCards
            , playerCount = Cards.getHandValue model.playerCards
            , numPlayerCards = List.length model.playerCards
            , win = model.gameState == Win
            , lose = model.gameState == Lose
            , tie = model.gameState == Tie
            }
    in
        ( { model | history = model.history ++ [ newHistoryRecord ] }, Cmd.none )





